FUNCTION_BLOCK "PRG_VGR_Ablauf"
TITLE = Program Ablauf VGR
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'A.Schaefer'
VERSION : 0.0
   VAR 
      lx_Init { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lx_Start_TON_State { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      lt_TON_Wait { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;
      ldt_MQTT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Date_And_Time;
      li_Return_LDT { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      li_Lights_old { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      lx_State_activ { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      li_StepCase { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
      ldi_Pos_SLD_X { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_SLD_Y { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ldi_Pos_SLD_Z { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      ls_Color { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      ls_Target { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : String;
      lfb_TON_Wait {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_TON_State {InstructionName := 'TON_TIME'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TON_TIME;
      lfb_R_Trig_NiO {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;
   END_VAR

   VAR_TEMP 
      ti_Counter : Int;
   END_VAR


BEGIN
	IF #lx_Init THEN
	    
	    // Restart after set Positioning
	    IF "gtyp_Setup".x_Set_Pos_Activ OR "gtyp_Setup".x_Color_Sensor_Calibration OR "gtyp_VGR".x_Start_Park_Position OR "gtyp_MPO".x_Error THEN
	        IF "gtyp_MPO".x_Error THEN
	            "gtyp_VGR".x_MPO_Req_Discard := FALSE;
	            "gtyp_VGR".x_MPO_Discards := FALSE;
	        END_IF;
	        #li_StepCase := 0;
	    END_IF;
	    
	    // wait time state
	    #lfb_TON_State(IN := NOT #lx_Start_TON_State,
	                   PT := T#2s);
	    
	    IF "gtyp_VGR".x_State_Process THEN
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	    END_IF;
	    
	    // state of the robot cyclically transmitted to the cloud
	    IF (#lfb_TON_State.Q OR (#li_Lights <> #li_Lights_old)) AND NOT #lx_Start_TON_State THEN
	        #li_Lights_old := #li_Lights;
	        #lx_Start_TON_State := TRUE;
	        #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.i_code := #li_Lights;
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.s_description := '';
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.s_station := 'vgr';
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.s_target := #ls_Target;
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.x_active := #lx_State_activ;
	        
	        "gtyp_Interface_Dashboard".Subscribe.PosPanTiltUnit.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	        
	        "gtyp_Interface_Dashboard".Subscribe.State_VGR.Workpiece := "gtyp_VGR".Workpiece;
	    END_IF;
	
	    // restart wait time state
	    IF NOT #lfb_TON_State.Q AND #lx_Start_TON_State THEN
	        #lx_Start_TON_State := FALSE;
	    END_IF;
	    
	    // rising edge Workpiece NiO
	    #lfb_R_Trig_NiO(CLK := "gtyp_VGR".x_Workpiece_NiO);
	    
	    IF #lfb_R_Trig_NiO.Q THEN
	        #lx_Start_TON_Wait := FALSE;
	        #lx_State_activ := FALSE;
	        #li_Lights := 4;
	        #ls_Target := '';
	        "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	        "gtyp_VGR".x_NFC_Start_First := FALSE;
	        "gtyp_VGR".x_NFC_Start := FALSE;
	        #li_StepCase := 70;
	    END_IF;
	    
	    // FB TON Wait
	    #lfb_TON_Wait(IN := #lx_Start_TON_Wait,
	                  PT := #lt_TON_Wait);
	    
	    // step chain VGR
	    CASE #li_StepCase OF
	            
	        0:  // init
	            #lx_Start_TON_Wait := FALSE;
	            #li_Lights := 1;
	            #lx_State_activ := FALSE;
	            #ls_Target := '';
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            "gtyp_VGR".x_HBW_Storage := FALSE;
	            "gtyp_VGR".x_HBW_Outsource := FALSE;
	            "gtyp_VGR".x_NFC_Start_First := FALSE;
	            "gtyp_VGR".x_NFC_Start := FALSE;
	            "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	            "QX_VGR_Compressor_Q7" := FALSE;
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            "gtyp_VGR".vertical_Axis.i_PWM := -1;
	            "gtyp_VGR".horizontal_Axis.i_PWM := -1;
	            "gtyp_VGR".rotate_Axis.i_PWM := -1;
	            
	            IF NOT "gtyp_Setup".x_Set_Pos_Activ AND NOT "gtyp_VGR".x_Start_Park_Position AND NOT "gtyp_MPO".x_Error THEN
	                #li_StepCase := 10;
	            END_IF;
	            
	        10: // homing vertical axis
	            #li_Lights := 2;
	            "gtyp_VGR".x_Ready_For_Outsource := TRUE;
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 20;
	            END_IF;
	            
	        20: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 30;
	            END_IF;
	            
	        30: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 40;
	            END_IF;
	            
	        40: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 50;
	            END_IF;
	            
	        50: // homing rotate axis
	            "gtyp_VGR".rotate_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                #li_StepCase := 60;
	            END_IF;
	            
	        60: // homed rotate axis
	            IF "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	                #li_StepCase := 70;
	            END_IF;
	            
	        70: // Deciding which route to take
	            
	            #li_Lights := 1;
	            #lx_State_activ := FALSE;
	            #ls_Target := '';
	            "gtyp_VGR".x_Ready_For_Outsource := TRUE;
	            
	            // Procedure - bad part
	            IF "gtyp_VGR".x_Workpiece_NiO THEN
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_Lights := 4;
	                #li_StepCase := 1200;
	                // Procedure - pick up finished parts blue
	            ELSIF NOT "IX_SLD_LightBarrierBlue_I7" THEN
	                #ldi_Pos_SLD_X := "gtyp_VGR".di_Pos_SLD_Blue_horizontal;
	                #ldi_Pos_SLD_Y := "gtyp_VGR".di_Pos_SLD_Blue_vertical;
	                #ldi_Pos_SLD_Z := "gtyp_VGR".di_Pos_SLD_Blue_rotate;
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_StepCase := 100;
	                // Procedure - pick up finished parts red
	            ELSIF NOT "IX_SLD_LightBarrierRed_I6" THEN
	                #ldi_Pos_SLD_X := "gtyp_VGR".di_Pos_SLD_Red_horizontal;
	                #ldi_Pos_SLD_Y := "gtyp_VGR".di_Pos_SLD_Red_vertical;
	                #ldi_Pos_SLD_Z := "gtyp_VGR".di_Pos_SLD_Red_rotate;
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_StepCase := 100;
	                // Procedure - pick up finished parts white
	            ELSIF NOT "IX_SLD_LightBarrierWhite_I5" THEN
	                #ldi_Pos_SLD_X := "gtyp_VGR".di_Pos_SLD_White_horizontal;
	                #ldi_Pos_SLD_Y := "gtyp_VGR".di_Pos_SLD_White_vertical;
	                #ldi_Pos_SLD_Z := "gtyp_VGR".di_Pos_SLD_White_rotate;
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_StepCase := 100;
	                // Procedure - outsource to manufacturing
	            ELSIF "gtyp_VGR".x_HBW_Outsource THEN
	                // Order State
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'ORDERED';
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := "gtyp_VGR".s_HBW_Outsource_Typ;
	                #li_StepCase := 400;
	                // Procedure - store raw parts
	            ELSIF (NOT "IX_SSC_LightBarrierStorage_I3") AND ("gtyp_HBW".i_Blue_Available + "gtyp_HBW".i_Red_Available + "gtyp_HBW".i_White_Available < 9) THEN
	                "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	                #li_Lights := 2;
	                "gtyp_VGR".x_HBW_Storage := TRUE;
	                #li_StepCase := 600;
	            END_IF;
	            
	            (**************************************************************************************************)
	            (****************************    Procedure - pick up finished parts    ****************************)
	            (**************************************************************************************************)
	        100: // Position of finished part 
	            
	            #li_Lights := 2;
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := #ldi_Pos_SLD_X;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	            
	            "gtyp_VGR".rotate_Axis.di_Target_Position := #ldi_Pos_SLD_Z;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= (#ldi_Pos_SLD_X + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= (#ldi_Pos_SLD_X - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= (#ldi_Pos_SLD_Z + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= (#ldi_Pos_SLD_Z - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 110;
	            END_IF;
	            
	        110: // position of finished part reached         
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= (#ldi_Pos_SLD_X + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= (#ldi_Pos_SLD_X - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= (#ldi_Pos_SLD_Z + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= (#ldi_Pos_SLD_Z - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= (#ldi_Pos_SLD_X + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= (#ldi_Pos_SLD_X - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND "gtyp_VGR".vertical_Axis.x_Referenced
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= (#ldi_Pos_SLD_Z + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= (#ldi_Pos_SLD_Z - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 120;
	            END_IF;
	            
	        120: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 130;
	            END_IF;
	            
	        130: // Position vertical finished part
	            "gtyp_VGR".vertical_Axis.di_Target_Position := #ldi_Pos_SLD_Y;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= (#ldi_Pos_SLD_Y + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= (#ldi_Pos_SLD_Y - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 140;
	            END_IF;
	            
	        140: // start compressor
	            "QX_VGR_Compressor_Q7" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 150;
	            END_IF;
	            
	        150: // turn on the vacuum and pick up the part
	            "QX_VGR_ValveVacuum_Q8" := true;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #lx_State_activ := TRUE;
	                #ls_Target := 'dso';
	                "gtyp_VGR".History := "gtyp_SLD".History;
	                "gtyp_VGR".Workpiece := "gtyp_SLD".Workpiece;
	                "gtyp_SLD".Workpiece.s_id := '0';
	                "gtyp_SLD".Workpiece.s_state := '';
	                "gtyp_SLD".Workpiece.s_type := '';
	                FOR #ti_Counter := 1 TO 8 DO
	                    "gtyp_SLD".History[#ti_Counter].i_code := 0;
	                    "gtyp_SLD".History[#ti_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                "gtyp_VGR".History[8].i_code := 800;
	                "gtyp_VGR".History[8].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                
	                "gtyp_Interface_Dashboard".Subscribe.State_SLD.x_active := FALSE;
	                
	                #li_StepCase := 160;
	            END_IF;
	            
	        160: // Position vertical preposition NFC
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 170;
	            END_IF;
	            
	        170: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 180;
	            END_IF;
	            
	        180: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 190;
	            END_IF;
	            
	        190: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 200;
	            END_IF;
	            
	        200: // Position horizontal/rotate NFC
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 210;
	            END_IF;
	            
	        210: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 220;
	            END_IF;
	            
	        220: // Position vertical NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 230;
	            END_IF;
	            
	        230: // Start write/read NFC
	            
	            "gtyp_VGR".x_NFC_Start := TRUE;
	            
	            IF "gtyp_VGR".x_NFC_Completed THEN
	                "gtyp_VGR".x_NFC_Start := FALSE;
	                #li_StepCase := 240;
	            END_IF;
	            
	        240: // homing vertical axis
	            
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 250;
	            END_IF;
	            
	        250: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 260;
	            END_IF;
	            
	        260: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 270;
	            END_IF;
	            
	        270: // Position horizontal/rotate DSO Output
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSO_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSO_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached
	                AND "IX_SSC_LightBarrierOutsourcing_I4" THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 280;
	            END_IF;
	            
	        280: // Position vertical DSO discard output
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSO_Discard_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSO_Discard_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSO_Discard_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".x_State_Process := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 290;
	            END_IF;
	            
	        290: // turn off vacuum
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	                // Order State
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'SHIPPED';
	                "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := "gtyp_VGR".Workpiece.s_type;
	                "gtyp_SSC".Workpiece := "gtyp_VGR".Workpiece;
	                "gtyp_SSC".History := "gtyp_VGR".History;
	                "gtyp_VGR".Workpiece.s_id := '0';
	                "gtyp_VGR".Workpiece.s_state := '';
	                "gtyp_VGR".Workpiece.s_type := '';
	                FOR #ti_Counter := 1 TO 8 DO
	                    "gtyp_VGR".History[#ti_Counter].i_code := 0;
	                    "gtyp_VGR".History[#ti_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                
	                "gtyp_Interface_Dashboard".Subscribe.State_DSO.x_active := TRUE;
	                
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 300;
	            END_IF;
	            
	        300: // turn off compressor
	            "QX_VGR_Compressor_Q7" := FALSE;
	            #lx_State_activ := FALSE;
	            #ls_Target := '';
	            #li_StepCase := 310;
	            
	        310: // homing vertical/horizontal axis
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced AND NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 320;
	            END_IF;
	            
	        320: // homed vertical/horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced AND "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 330;
	            END_IF;
	            
	        330: // homing rotate axis
	            "gtyp_VGR".rotate_Axis.x_Reference := TRUE;
	            IF NOT "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                #li_StepCase := 340;
	            END_IF;
	            
	        340: // homed rotate axis
	            IF "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	                #li_StepCase := 350;
	            END_IF;
	            
	        350: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 70;
	            END_IF;
	            
	            (*******************************************************************************************)
	            (****************************           outsource HBW           ****************************)
	            (*******************************************************************************************)
	        400: // Position rotate HBW and homing vertical/horizontal axis
	            #li_Lights := 2;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced AND NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 410;
	            END_IF;
	            
	        410: // Position reached rotate HBW and homed vertical/horizontal axis
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced
	                AND "gtyp_VGR".vertical_Axis.x_Referenced
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 420;
	            END_IF;
	            
	        420: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 430;
	            END_IF;
	            
	        430: // Position horizontal HBW 
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 440;
	            END_IF;
	            
	        440: // Container Available start pick up
	            IF "gtyp_HBW".x_HBW_Container_Available THEN
	                #li_StepCase := 450;
	            END_IF;
	            
	        450: // Position vertical Collect HBW
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_Collect_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_Collect_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_Collect_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 460;
	            END_IF;
	            
	        460: // turn on compressor
	            "QX_VGR_Compressor_Q7" := TRUE;
	            "gtyp_VGR".x_MPO_Req_Discard := TRUE;
	            #li_StepCase := 470;
	            
	        470: // turn on vacuum
	            "QX_VGR_ValveVacuum_Q8" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                "Simulation_Variables".HBW_Product_InOut_Color := 0;
	                "Simulation_Variables".HBW_Product_InOut_Toggle := NOT "Simulation_Variables".HBW_Product_InOut_Toggle;
	                #li_StepCase := 480;
	            END_IF;
	            
	        480: // homing vertical axis
	            
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".x_HBW_PickedUp := TRUE;
	                #li_StepCase := 485;
	            END_IF;
	            
	        485: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 490;
	            END_IF;
	            
	        490: // homing horizontal axis
	            
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 495;
	            END_IF;
	            
	        495: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 500;
	            END_IF;
	            
	        500: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_State_activ := TRUE;
	                #ls_Target := 'mpo';
	                "gtyp_VGR".x_HBW_PickedUp := FALSE;
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 510;
	            END_IF;
	            
	        510: // Position rotate MPO
	            
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 515;
	            END_IF;
	            
	        515: // Position horizontal/pre vertical MPO
	            
	            IF (NOT "IX_MPO_RefSwitchVac_PosOven_I8") THEN
	                "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_horizontal;
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            END_IF;
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 520;
	            END_IF;
	            
	        520: // MPO ready to discard - Position vertical MPO
	            
	            IF "gtyp_MPO".x_Discard_Ready THEN
	                "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_vertical;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	                
	                IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                    AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                    AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                    "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                    //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                    #li_StepCase := 530;
	                    "gtyp_VGR".x_MPO_Req_Discard := FALSE;
	                END_IF;
	            END_IF;
	            
	        530: // turn off vacuum
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            #li_StepCase := 540;
	            
	        540: // turn off compressor
	            "QX_VGR_Compressor_Q7" := FALSE;
	            "gtyp_VGR".x_MPO_Discards := TRUE;
	            // Order State
	            "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	            "gtyp_VGR".x_State_Process := TRUE;
	            "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'IN_PROCESS';
	            "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := "gtyp_VGR".Workpiece.s_type;
	            #li_StepCase := 550;
	            
	        550: // Workpiece discard accepted - Position pre vertical MPO
	            
	            IF "gtyp_MPO".x_MPO_Discards_Accepted THEN
	                
	                "gtyp_VGR".Workpiece.s_id := '0';
	                "gtyp_VGR".Workpiece.s_state := '';
	                "gtyp_VGR".Workpiece.s_type := '';
	                FOR #ti_Counter := 1 TO 8 DO
	                    "gtyp_VGR".History[#ti_Counter].i_code := 0;
	                    "gtyp_VGR".History[#ti_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                
	                //Clear the workiece parameters
	                "gtyp_VGR".Worpiece_Parameters.DoOven := TRUE;
	                "gtyp_VGR".Worpiece_Parameters.OvenTime := T#4s;
	                "gtyp_VGR".Worpiece_Parameters.DoSaw := TRUE;
	                "gtyp_VGR".Worpiece_Parameters.SawTime := T#4s;
	                
	                "gtyp_VGR".x_Ready_For_Order := TRUE;
	                
	                "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	                
	                IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                    AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_MPO_vertical - "gtyp_VGR".di_Offset_Pos_MPO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                    AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                    "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                    "gtyp_VGR".x_MPO_Discards := FALSE;
	                    //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                    #li_StepCase := 560;
	                END_IF;
	            END_IF;
	            
	        560: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 570;
	            END_IF;
	            
	        570: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                "gtyp_VGR".x_MPO_Discards := FALSE;
	                //#li_StepCase := 580;
	                #li_StepCase := 0;
	            END_IF;
	            
	            (*******************************************************************************************)
	            (**************************      Procedure - store raw parts      **************************)
	            (*******************************************************************************************)
	            
	        600:// approach pick-up position dsi with vertical, horizontal, rotate axis
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSI_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSI_Collect_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_DSI_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_Collect_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_Collect_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_Collect_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_Collect_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_DSI_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_DSI_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 610;
	            END_IF;
	            
	        610:// set status 100 raw goods delivered
	            #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	            "gtyp_VGR".Workpiece.s_state := 'RAW';
	            "gtyp_VGR".History[1].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            "gtyp_VGR".History[1].i_code := 100;
	            #li_StepCase := 620;
	            
	        620:// wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 630;
	            END_IF;
	            
	        630:// turn on compressor and wait
	            "QX_VGR_Compressor_Q7" := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 640;
	            END_IF;
	            
	        640:// turn on vacuum 
	            "QX_VGR_ValveVacuum_Q8" := true;
	            
	            #li_StepCase := 650;
	            
	        650:// Position vertical NFC
	            #lx_State_activ := TRUE;
	            #ls_Target := 'hbw';
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 660;
	            END_IF;
	            
	        660: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 670;
	            END_IF;
	            
	        670: // Position horizontal/rotate NFC
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 680;
	            END_IF;
	            
	        680: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 690;
	            END_IF;
	            
	        690: // Position vertical NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 700;
	            END_IF;
	            
	        700: // Start delete/write/read NFC 
	            "gtyp_VGR".x_NFC_Start_First := TRUE;
	            
	            IF "gtyp_VGR".x_NFC_Completed THEN
	                "gtyp_VGR".x_NFC_Start_First := FALSE;
	                #li_StepCase := 710;
	            END_IF;
	            
	        710: // Position vertical pre NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 720;
	            END_IF;
	            
	        720: // Position horizontal/rotate Color
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_Color_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_Color_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 730;
	            END_IF;
	            
	        730: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 740;
	            END_IF;
	            
	        740: // Position vertical Color
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_Color_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_Color_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_Color_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 750;
	            END_IF;
	            
	        750: // evaluate color workpiece
	            #ls_Color := '';
	            
	            IF "IW_SSC_ColorSensor_A1" >= "gtyp_SSC".w_Threshold_Red_Blue THEN
	                //               IF "IW_SSC_ColorSensor" > 16000 AND "IW_SSC_ColorSensor" < 17500 THEN
	                #ls_Color := 'BLUE';
	            ELSIF "IW_SSC_ColorSensor_A1" <= "gtyp_SSC".w_Threshold_White_Red THEN
	                //            ELSIF "IW_SSC_ColorSensor" > 5000 AND "IW_SSC_ColorSensor" < 11000 THEN
	                #ls_Color := 'WHITE';
	            ELSIF "IW_SSC_ColorSensor_A1" > "gtyp_SSC".w_Threshold_White_Red AND "IW_SSC_ColorSensor_A1" < "gtyp_SSC".w_Threshold_Red_Blue THEN
	                //            ELSIF "IW_SSC_ColorSensor" > 11000 AND "IW_SSC_ColorSensor" < 16000 THEN
	                #ls_Color := 'RED';
	            END_IF;
	            
	            #li_Return_LDT := RD_SYS_T(#ldt_MQTT);
	            "gtyp_VGR".History[2].ldt_ts := DT_TO_LDT(#ldt_MQTT);
	            "gtyp_VGR".History[2].i_code := 200;
	            "gtyp_VGR".Workpiece.s_type := #ls_Color;
	            
	            //UPDATE OBSERVED COLOR IN WORKPIECE STATES
	            "gtyp_VGR".Workpiece.Workpiece_States.s_ObservedColor:=#ls_Color;
	            "gtyp_VGR".Workpiece.Workpiece_States.w_ObservedColorValue := "IW_SSC_ColorSensor_A1";
	            "gtyp_VGR".Workpiece.Workpiece_States.ldt_Color := DT_TO_LDT(#ldt_MQTT);
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 760;
	            END_IF;
	            
	        760: // Position vertical pre NFC
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 770;
	            END_IF;
	            
	        770: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 780;
	            END_IF;
	            
	        780: // Position horizontal/rotate NFC
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 790;
	            END_IF;
	            
	        790: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 800;
	            END_IF;
	            
	        800: // Position vertical NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 810;
	            END_IF;
	            
	        810: // Start write/read NFC Color
	            
	            "gtyp_VGR".x_NFC_Start := TRUE;
	            
	            IF "gtyp_VGR".x_NFC_Completed THEN
	                "gtyp_VGR".x_NFC_Start := FALSE;
	                #li_StepCase := 820;
	            END_IF;
	            
	        820: // Position vertical pre NFC
	            
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NFC_vertical - "gtyp_VGR".di_Offset_Pos_DSI_NFC_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 830;
	            END_IF;
	            
	        830: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 840;
	            END_IF;
	            
	        840: // Position rotate HBW and homing horizontal/vertical axis
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced AND NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 850;
	            END_IF;
	            
	        850: // Position rotate HBW reached and homed horizontal/vertical axis
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	            END_IF;
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced
	                AND "gtyp_VGR".vertical_Axis.x_Referenced
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 860;
	            END_IF;
	            
	        860: // wait sequence
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                #lx_Start_TON_Wait := FALSE;
	                #li_StepCase := 870;
	            END_IF;
	            
	        870: // Position horizontal HBW
	            
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                #li_StepCase := 880;
	            END_IF;
	            
	        880: // container available start drop down
	            IF "gtyp_HBW".x_HBW_Container_Available THEN
	                #li_StepCase := 890;
	            END_IF;
	            
	        890: // Position vertical discard HBW
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_HBW_Discard_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_HBW_Discard_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_HBW_Discard_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 900;
	            END_IF;
	            
	        900: // turn off vacuum
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            
	            IF "gtyp_VGR".Workpiece.s_type = 'WHITE' THEN
	                "Simulation_Variables".HBW_Product_InOut_Color := 1;
	            ELSIF "gtyp_VGR".Workpiece.s_type = 'RED' THEN
	                "Simulation_Variables".HBW_Product_InOut_Color := 2;
	            ELSIF "gtyp_VGR".Workpiece.s_type = 'BLUE' THEN
	                "Simulation_Variables".HBW_Product_InOut_Color := 3;
	            END_IF;
	            "Simulation_Variables".HBW_Product_InOut_Toggle := NOT "Simulation_Variables".HBW_Product_InOut_Toggle;
	            
	            #li_StepCase := 910;
	            
	        910: // turn off compressor
	            "QX_VGR_Compressor_Q7" := FALSE;
	            "gtyp_VGR".x_HBW_Discards := TRUE;
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#500ms;
	            
	            IF #lfb_TON_Wait.Q AND "gtyp_HBW".x_HBW_Discards_Accepted THEN
	                #lx_State_activ := FALSE;
	                #ls_Target := '';
	                "gtyp_VGR".x_HBW_Discards := FALSE;
	                "gtyp_VGR".x_HBW_Storage := FALSE;
	                #lx_Start_TON_Wait := FALSE;
	                
	                "gtyp_VGR".Workpiece.s_id := '';
	                "gtyp_VGR".Workpiece.s_state := '';
	                "gtyp_VGR".Workpiece.s_type := '';
	                FOR #ti_Counter := 1 TO 8 DO
	                    // Statement section FOR
	                    "gtyp_VGR".History[#ti_Counter].i_code := 0;
	                    "gtyp_VGR".History[#ti_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	                END_FOR;
	                
	                #li_StepCase := 920;
	            END_IF;
	            
	        920: // homing vertical axis
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 930;
	            END_IF;
	            
	        930: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 940;
	            END_IF;
	            
	        940: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 950;
	            END_IF;
	            
	        950: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                //#li_StepCase := 960;
	                #li_StepCase := 0;
	            END_IF;
	            
	            (*******************************************************************************************)
	            (**************************      Procedure - bad part             **************************)
	            (*******************************************************************************************)
	        
	        1200:// homing vertical axis
	            "gtyp_VGR".Workpiece.s_id := '0';
	            "gtyp_VGR".Workpiece.s_state := '';
	            "gtyp_VGR".Workpiece.s_type := '';
	            FOR #ti_Counter := 1 TO 8 DO
	                "gtyp_VGR".History[#ti_Counter].i_code := 0;
	                "gtyp_VGR".History[#ti_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	            END_FOR;
	            
	            IF "gtyp_HBW".x_HBW_Container_Available THEN
	                "gtyp_VGR".x_HBW_Discards := TRUE;
	            END_IF;
	            
	            IF "gtyp_HBW".x_HBW_Discards_Accepted OR "gtyp_HBW".x_HBW_PickedUp_Accepted THEN
	                "gtyp_VGR".x_HBW_Discards := FALSE;
	                "gtyp_VGR".x_HBW_PickedUp := FALSE;
	                "gtyp_HBW".x_HBW_Discards_Accepted := FALSE;
	                "gtyp_HBW".x_HBW_PickedUp_Accepted := FALSE;
	            END_IF;
	            
	            #li_Lights := 2;
	            "gtyp_VGR".vertical_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                #li_StepCase := 1210;
	            END_IF;
	            
	        1210: // homed vertical axis
	            IF "gtyp_VGR".vertical_Axis.x_Referenced THEN
	                "gtyp_VGR".vertical_Axis.x_Reference := FALSE;
	                #li_StepCase := 1220;
	            END_IF;
	            
	        1220: // homing horizontal axis
	            "gtyp_VGR".horizontal_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                #li_StepCase := 1230;
	            END_IF;
	            
	        1230: // homed horizontal axis
	            IF "gtyp_VGR".horizontal_Axis.x_Referenced THEN
	                "gtyp_VGR".horizontal_Axis.x_Reference := FALSE;
	                #li_StepCase := 1240;
	            END_IF;
	            
	        1240: // homing rotate axis
	            "gtyp_VGR".rotate_Axis.x_Reference := TRUE;
	            
	            IF NOT "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                #li_StepCase := 1250;
	            END_IF;
	            
	        1250: // homed horizontal axis
	            IF "gtyp_VGR".rotate_Axis.x_Referenced THEN
	                "gtyp_VGR".rotate_Axis.x_Reference := FALSE;
	                #li_StepCase := 1260;
	            END_IF;
	            
	        1260: // Position vertical/horizontal/rotate NiO
	            "gtyp_VGR".horizontal_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NiO_horizontal;
	            "gtyp_VGR".horizontal_Axis.x_Start_Positioning := TRUE;
	            "gtyp_VGR".vertical_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NiO_vertical;
	            "gtyp_VGR".vertical_Axis.x_Start_Positioning := TRUE;
	            //"gtyp_VGR".vertical_Axis.i_PWM := 500;
	            "gtyp_VGR".rotate_Axis.di_Target_Position := "gtyp_VGR".di_Pos_NiO_rotate;
	            "gtyp_VGR".rotate_Axis.x_Start_Positioning := TRUE;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached THEN
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	            END_IF;
	            
	            IF ("gtyp_VGR".horizontal_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_horizontal + "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".horizontal_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_horizontal - "gtyp_VGR".horizontal_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".horizontal_Axis.x_Position_Reached
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_vertical + "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".vertical_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_vertical - "gtyp_VGR".vertical_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".vertical_Axis.x_Position_Reached
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position <= ("gtyp_VGR".di_Pos_NiO_rotate + "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND ("gtyp_VGR".rotate_Axis.di_Actual_Position >= ("gtyp_VGR".di_Pos_NiO_rotate - "gtyp_VGR".rotate_Axis.Config.di_Pos_Window))
	                AND "gtyp_VGR".rotate_Axis.x_Position_Reached THEN
	                "gtyp_VGR".horizontal_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".vertical_Axis.x_Start_Positioning := FALSE;
	                "gtyp_VGR".rotate_Axis.x_Start_Positioning := FALSE;
	                //"gtyp_VGR".vertical_Axis.i_PWM := 800;
	                #li_StepCase := 1270;
	            END_IF;
	            
	        1270: // turn off vacuum
	            "QX_VGR_ValveVacuum_Q8" := FALSE;
	            #li_StepCase := 1280;
	            
	        1280: // turn off compressor
	            
	            #lx_Start_TON_Wait := TRUE;
	            #lt_TON_Wait := T#1000ms;
	            
	            IF #lfb_TON_Wait.Q THEN
	                "QX_VGR_Compressor_Q7" := FALSE;
	                #lx_Start_TON_Wait := FALSE;
	                "gtyp_VGR".x_Workpiece_NiO := FALSE;
	                "gtyp_VGR".x_HBW_Discards := FALSE;
	                #li_Lights := 1;
	                #li_StepCase := 0;
	            END_IF;
	            // Statement section ELSE       
	        ELSE
	            ;
	    END_CASE;
	    
	ELSE
	    "gtyp_VGR".Workpiece.s_id := '';
	    "gtyp_VGR".Workpiece.s_state := '';
	    "gtyp_VGR".Workpiece.s_type := '';
	    // Order State
	    "gtyp_VGR".x_State_Process := FALSE;
	    "gtyp_Interface_Dashboard".Subscribe.State_Order.ldt_ts := DT_TO_LDT(#ldt_MQTT);
	    "gtyp_Interface_Dashboard".Subscribe.State_Order.s_state := 'WAITING_FOR_ORDER';
	    "gtyp_Interface_Dashboard".Subscribe.State_Order.s_type := '';
	    FOR #ti_Counter := 1 TO 8 DO
	        "gtyp_VGR".History[#ti_Counter].i_code := 0;
	        "gtyp_VGR".History[#ti_Counter].ldt_ts := DT#1990-01-01-00:00:00;
	    END_FOR;
	    
	    "gtyp_VGR".x_Start_Park_Position := FALSE;
	    "gtyp_VGR".x_Park_Position_Reached := FALSE;
	    "gtyp_VGR".x_NFC_Start_First := FALSE;
	    "gtyp_VGR".x_NFC_Start := FALSE;
	    "gtyp_VGR".x_NFC_Completed := FALSE;
	    "gtyp_VGR".x_HBW_Storage := FALSE;
	    "gtyp_VGR".x_HBW_Outsource := FALSE;
	    "gtyp_VGR".s_HBW_Outsource_Typ := '';
	    "gtyp_VGR".x_HBW_Discards := FALSE;
	    "gtyp_VGR".x_HBW_PickedUp := FALSE;
	    "gtyp_VGR".x_MPO_Req_Discard := FALSE;
	    "gtyp_VGR".x_MPO_Discards := FALSE;
	    "gtyp_VGR".x_Ready_For_Outsource := FALSE;
	    "gtyp_VGR".x_State_Process := FALSE;
	    "gtyp_VGR".x_Workpiece_NiO := FALSE;
	    
	    "gtyp_VGR".x_Ready_For_Order := TRUE;
	    
	    #li_Lights := 1;
	    #lx_Init := TRUE;
	END_IF;
END_FUNCTION_BLOCK

